# Statements

## 组织直线型代码

### 明确顺序的语句

- 设法组织代码，使依赖关系变得明显

	- init
	- cacl
	- print

- 利用子程序参数明确显示依赖关系
- 用注释对不清晰的依赖关系进行说明

	- 优先依赖其他技术

- 用断言或者错误处理代码来检查依赖关系

	- hasInit

### 顺序无关的语句

- 就近原则
- 易于自上而下的阅读

	- 减少跳行

- 相关语句组织在一起

## 使用条件语句

### if语句

- 简化if-then语句

	- 首先写正常代码路径，再处理不常见情况
	- 确保对于等量的分支是正确的

		- > >= < <= off-by-one

	- 正常情况放在if后面而不要放else后面
	- 让if字句后面跟随一个有意义的语句
	- 考虑else子句

		- 一般都有必要

	- 测试else子句的正确性
	- 检查if和else子句是不是弄反了

- if-then-else语句串

	- 利用布尔函数调用简化复杂的检测
	- 把最常见的情况放在最前面
	- 确保所有情况都考虑到了

		- 最后一个else子句提供错误或断言

	- 若语言支持，替换成其他结构

### case语句

- 选择最有效的排列顺序

	- 事件驱动程序的case语句会比较长
	- 重要性相同

		- 按字母顺序或按数字顺序排列

	- 把正常情况放在前面

		- 注释说明

	- 按执行效率排列

		- 加速检索

- 诀窍

	- 简化每种情况对应的操作

		- 子程序简化

	- 不要为了使用case语句而刻意制造一个变量

		- 复杂表达式付给一个命名准确的布尔变量或函数

	- 把default子句只用于检查真正的默认情况

		- case语句的标号（label）具有自动说明功能

	- 利用default子句来检测错误

		- 仔细检查以确认每一个可能进入case语句的值都是合法的

	- 在C++和Java里，避免代码执行越过一条case子句的末尾
	- 在C++里，在默认明确无误地标明需要穿越执行的程序流程

		- 尽量避免

## 控制循环

### 分类

- 种类

	- 计数循环
	- 连续求值循环
	- 无限循环
	- 迭代器循环

- 灵活度、检查位置
- while循环

	- 灵活
	- 预先不知道迭代次数

- 带退出的循环

	- 如果把循环条件检测放在循环开始或结束处，就需要写出一个半循环
	- 把所有退出条件放在一处
	- 用注释来阐明操作意图
	- 单入单出的结构化控制结构

		- 首选的循环控制

	- 接近于人类思考迭代型控制的方式
	- 非正常情况

		- goto模拟break

- for循环

	- 执行次数固定的循环
	- 循环控制代码集中在一处
	- 不要直接修改下标值的方式终止循环

		- 改为while

- foreach循环

	- 数组，容器

### 循环控制

- 把循环内部当做一个子程序看待
- 进入循环

	- 只从一个位置进入循环
	- 把初始化代码紧放在循环前面
	- 用while(true)表示无限循环

		- 或者for(;;)

	- 在适当的情况下多使用for循环
	- 在while循环更适用时，不要使用for循环

		- for循环头的位置保留给循环控制语句

			- 区分内务语句

- 处理好循环体

	- 用大括号把循环中的语句括起来
	- 避免空循环
	- 把循环内务操作要么放在循环的开始，要么放在循环的末尾
	- 一个循环只做一件事

		- 和子程序一样

- 退出循环

	- 设法确认循环能够终止
	- 使循环终止条件看起来很明显
	- 不要为了终止循环而胡乱改动for循环的下标

		- 循环计数器不由循环体控制

	- 避免出现依赖于循环下标最终值的代码

		- 使用变量

	- 考虑使用安全计数器

		- 增加了复杂度
		- 应用于关键的循环

- 提前退出循环

	- 考虑在while循环中使用break语句而不用布尔标记

		- 多个break条件放到一些独立的语句并靠近产生break的代码以减少嵌套

	- 小心那些有很多break散步其中的循环

		- 纽约电话系统停机故障

			- do-switch-if

	- 在循环开始处用continue进行判断

		- 避免if判断使循环体整体锁进
		- 循环中部或尾部改用if

	- 如果语言支持，使用带标号break结构

		- do-switch-if问题

	- 使用break和continue时要小心谨慎

		- 循环退出条件只写在一条语句

- 检查端点

	- 开始、中间和最终情况
	- off-by-one
	- 头脑模拟和手工运算

- 循环变量

	- 用整数或者枚举类型表示数组和循环的边界
	- 在嵌套循环中使用有意义的变量名来提高其可读性
	- 使用有意义的名字来避免循环下标串话

		- i,j,k问题

	- 把循环下标的变量的作用域限制在本循环内

		- 不要依赖于编译器实现

- 循环长度

	- 尽可能短，一目了然

		- 15-20行

	- 嵌套限制在3层以内

		- 子程序提取
		- 简化控制结构

	- 把长循环的内容移到子程序里
	- 让长循环格外清晰

		- 单一出口
		- 退出条件清晰无误

### 创建循环

- 由内而外

	- 字面量编写，缩进它，加循环，使用循环下标或计算表达式替换字面量
	- 详细步骤

		- 在注释里写下循环体需要执行的操作步骤
		- 注释转化为代码
		- 加入下标
		- 写出必要的初始化代码

### 循环与数组

- 基于特定语言

## 不常见的控制结构

### 多处返回

- 如果能增强可读性，那么就使用return

	- 如检测出错

- 用防卫子句来简化复杂的错误处理
- 减少每个子程序中return的数量

### 递归

- 使用递归

	- 问题的小部分容易解决
	- 问题的大部分很容易分解成众多的小部分时
	- 带来简单、优雅但是难懂的解

		- 比如走迷宫类型问题

- 技巧

	- 确认递归能够停止

		- 含有一条非递归的路径

	- 使用安全计数器防止出现无穷递归
	- 把递归限制在一个子程序内

		- 依靠脑力来管理位于一个子程序内的递归已经够困难了

	- 留心栈空间

		- 安全计数器上限
		- 留意内存消耗大的对象

	- 不要用递归去计算阶乘和斐波那契数列

		- 除了速度缓慢，并且无法预测运行期间的内存使用情况以外，用递归写出的子程序要比用循环写出的子程序更难理解
		- 使用递归之前考虑替代方案

			- 栈和循环

### goto

- 反对的观点

	- 很难安排好格式
	- 破坏编译器的优化特征
	- 运行速度慢
	- 代码更大
	- 违背代码应该严格自上而下运行的原则

- 支持的观点

	- 在分配资源、使用资源后再释放资源的子程序里非常有用

- 应用场景

	- 错误处理

		- goto
		- 状态变量替代
		- try finally替代

	- else子句中共享代码

		- 子程序替代

- 使用原则

	- 不直接支持结构化控制语句的语言里，goto可以模拟控制结构
	- 如果语言内置了等价的控制结构，那么就不要用goto
	- 衡量goto实际带来的性能提升
	- 除非要模拟控制结构，每个子程序只使用一个goto标号且尽量向前跳转
	- 确认goto标号都用到且不会产生执行不到的代码

### 观点

- 软件开发这一领域是在限制程序员对代码的使用中得到发展的
- 放弃注重灵活方便而忽视复杂度管理能力的结构

## 表驱动法

### 问题

- 怎么从表中查询条目
- 应该在表里面寸什么

### 直接访问表

- 替代基于逻辑的方法

	- if/else

- 替代面向对象的方法

	- 多态

- 数据要比逻辑灵活，修改数据是很容易的

	- 基于表内容使用多态或case

- 构造查询键值（范围）

	- 复制信息从而能够直接使用键值

		- 表结构简单
		- 访问表的操作也简单
		- 冗余信息浪费空间
		- 增加错误可能性

	- 转换键值

		- 创建转换函数
		- 创建子程序转换
		- 使用语言提供的关联型容器

			- HashMap

### 索引访问表

- 先用基本类型的数据从一张索引表查出一个键值，再用键值查询主数据
- 优点

	- 节约空间
	- 索引表操作方便，可存在多个索引表
	- 便于维护

		- 把索引访问数据的代码提取中单独的子程序

### 阶梯访问表

- 表中的记录对于不同的数据范围有效，而不是对不同的数据点有效
- 适合处理无规则的数据
- 非常灵活并容易修改
- 细节

	- 留心端点

		- 考虑每一个阶梯区的上界
		- 为最高一级区间的最高点假拟出一个值
		- 注意<和<=

	- 考虑二分查找取代顺序查找

		- 把端点作为特殊情况看待

	- 考虑用索引访问来取代阶梯技术

		- 关注查找耗时

	- 把阶梯表查询操作提取成单独的子程序

## 一般控制问题

### 布尔表达式

- 用true和false做布尔判断

	- 不要用0和1
	- 如果语言不支持则用预处理宏或者全局变量创建
	- 隐式地比较布尔值与true和false

		- 接近自然语言

- 简化复杂的表达式

	- 拆分复杂的判断并引入新的布尔变量
	- 把复杂的表达式做成布尔函数

		- 改善可读性
		- 比注释更好

	- 用决策表代替复杂的条件

- 编写肯定形式的布尔表达式

	- 在if语句中，把判断条件从否定形式转换为肯定形式，并且互换if和else子句中的代码
	- 反义变量

		- 不用修改代码

- 用狄摩根定理简化否定的布尔判断

	- not A and not B == not (A or B)
	- not A or not B == not(A and B)

- 用括号使布尔表达式更清晰

	- 降低对代码阅读者的要求
	- 不会使代码可读性依赖于你自己或者代码阅读者对求值优先级的深度理解
	- 用一种简单的技术技巧来使括号对称
	- 把布尔表达式全括在括号里面

- 理解布尔表达式求值

	- 是否采用短路/惰性求值策略

		- 内存保护违例
		- java &和|完整求值问题

	- 使用嵌套的判断语句来明确你的用意，而不要依赖于求值顺序和短路求值

- 按照数轴的顺序编写数值表达式

	- 从左至右，从小到大

	  if(10<amount && amount<100){
	  	// do sth
	  }

- 与0比较的指导原则

	- 隐式地比较逻辑变量
	- 把数和0相比较
	- 在C中显式地比较字符和零终止符（'\0'）

		- 强调表达式是在处理字符数据
		- 有一些C传统并不是基于最大化的可读性或者可维护性，这个问题在C++和STL中得到改善

	- 把指针与NULL相比较

- 常见问题

	- 在C家族语言中，应该把常量放在比较的左端

		- 优先提供 = 和 == 编译错误
		- 优先使用数轴排序法

	- 在C++中，可以考虑创建预处理宏来替换&&，||和==（不得已才这么做）

		- 降低了代码可读性
		- 优先采用编译器警告

	- 在Java中，理解 == 和 equals 之间的差异

### 复合语句（语句块）

- 指一组语句，该组语句被视为一条单一的语句
- 把括号对一起写出

	- 先写块的开始和结束部分，然后再填充中间部分
	- 这种方法适用于所有的块结构

- 用括号来把条件表达清楚

	- 不要在if后面只写一条语句
	- 用块表达你的用意，无论块内的代码行数是1还是20

### 空语句

- 小心使用空语句

	- 让空语句中的分号自占一行，并加以缩减
	- 或者使用一组空括号

- 为空语句创建一个DoNothing()预处理宏或者内联函数

	- 或者子程序

- 考虑如果换用一个非空的循环体是否会让代码更清晰

	- 不要利用循环控制代码的副作用

### 驯服危险的深层嵌套

- 深层嵌套与管理复杂度相违背
- 策略

	- 通过重复检测条件中的某一部分来简化嵌套的if语句

		- 必须容忍使用一个更复杂的判断

	- 用break块来简化嵌套if

		- 通过取反提前退出

	- 把嵌套if转化成一组if-then-else语句

		- 整齐排列数值
		- 书写else-if子句中的表达式不依赖于前面判断结果的语句

			- 不需要else子句就能工作
			- else避免不必要的重复判断

	- 把嵌套if转换成case语句
	- 把深层嵌套的代码抽取出来放进单独的子程序

		- 当嵌套是由于条件和迭代二者共同产生的时候特别有效
		- if-then-else分支保留在主循环显示决策的分支，分支中的语句提取成单独的子程序
		- 优点

			- 结构更简单并容易理解
			- 支持一屏阅读、修改和调试
			- 带来模块化的其他基本好处
			- 可以拆分成case语句

	- 使用一种更面向对象的方法

		- 工厂模式+多态

	- 重新设计深层嵌套的代码

		- 在面向对象的程序设计里面出现case语句就说明代码没做好分解
		- 复杂的代码表明你没有充分地理解你的程序

	- 其他

		- 用状态变量重写代码
		- 用防卫子句来退出子程序
		- 使用异常

### 结构化编程

- 核心思想

	- 只采用单入单出的控制结构

- 程序按照编写的方式自上而下运行，不做不可预知的跳转
- 组成部分

	- 顺序
	- 选择

		- if-then-else/switch-case

	- 迭代

- 中心论点

	- 任何一种控制流都可以由顺序、选择和迭代这三种结构生成

		- 不建议使用goto,break,continue,throw,catch,return

### 控制结构与复杂度

- 控制结构对程序整体复杂度影响极大
- 衡量标准

	- 为了理解应用程序，你必须在同一时间记住的智力实体数量

		- 编程比其他任何活动都要专心

- 程序复杂度决定了理解程序需要花费的精力

	- 程序复杂度是由它的控制流来定义的

- 重要性

	- 大脑容量有限
	- 与不可靠的代码和频繁出现的错误息息相关

- 一般原则

	- 5-9个智力实体
	- 降低应用程序的复杂度以及理解所需的专心程度
	- 复杂度度量

		- 决策点数量

			- 从1开始
			- 遇到 if,while,for,and,or 加1
			- 给case语句每一种情况都加1

		- 处理度量结果

			- 0-5 ok
			- 5-10 简化
			- 10+ 拆分子程序

				- 提取子程序不会降低整个程序的复杂度，但会把决策点转移到其他地方，降低了同一时间必须关注的复杂度

	- 其他类型复杂度（复合度量）

		- 数据量
		- 嵌套层数
		- 代码行数
		- 变量跨度
		- 变量生存期
		- 输入输出量

*XMind: ZEN - Trial Version*