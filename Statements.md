# Statements

## 组织直线型代码

### 明确顺序的语句

- 设法组织代码，使依赖关系变得明显

	- init
	- cacl
	- print

- 利用子程序参数明确显示依赖关系
- 用注释对不清晰的依赖关系进行说明

	- 优先依赖其他技术

- 用断言或者错误处理代码来检查依赖关系

	- hasInit

### 顺序无关的语句

- 就近原则
- 易于自上而下的阅读

	- 减少跳行

- 相关语句组织在一起

## 使用条件语句

### if语句

- 简化if-then语句

	- 首先写正常代码路径，再处理不常见情况
	- 确保对于等量的分支是正确的

		- > >= < <= off-by-one

	- 正常情况放在if后面而不要放else后面
	- 让if字句后面跟随一个有意义的语句
	- 考虑else子句

		- 一般都有必要

	- 测试else子句的正确性
	- 检查if和else子句是不是弄反了

- if-then-else语句串

	- 利用布尔函数调用简化复杂的检测
	- 把最常见的情况放在最前面
	- 确保所有情况都考虑到了

		- 最后一个else子句提供错误或断言

	- 若语言支持，替换成其他结构

### case语句

- 选择最有效的排列顺序

	- 事件驱动程序的case语句会比较长
	- 重要性相同

		- 按字母顺序或按数字顺序排列

	- 把正常情况放在前面

		- 注释说明

	- 按执行效率排列

		- 加速检索

- 诀窍

	- 简化每种情况对应的操作

		- 子程序简化

	- 不要为了使用case语句而刻意制造一个变量

		- 复杂表达式付给一个命名准确的布尔变量或函数

	- 把default子句只用于检查真正的默认情况

		- case语句的标号（label）具有自动说明功能

	- 利用default子句来检测错误

		- 仔细检查以确认每一个可能进入case语句的值都是合法的

	- 在C++和Java里，避免代码执行越过一条case子句的末尾
	- 在C++里，在默认明确无误地标明需要穿越执行的程序流程

		- 尽量避免

## 控制循环

### 分类

- 种类

	- 计数循环
	- 连续求值循环
	- 无限循环
	- 迭代器循环

- 灵活度、检查位置
- while循环

	- 灵活
	- 预先不知道迭代次数

- 带退出的循环

	- 如果把循环条件检测放在循环开始或结束处，就需要写出一个半循环
	- 把所有退出条件放在一处
	- 用注释来阐明操作意图
	- 单入单出的结构化控制结构

		- 首选的循环控制

	- 接近于人类思考迭代型控制的方式
	- 非正常情况

		- goto模拟break

- for循环

	- 执行次数固定的循环
	- 循环控制代码集中在一处
	- 不要直接修改下标值的方式终止循环

		- 改为while

- foreach循环

	- 数组，容器

### 循环控制

- 把循环内部当做一个子程序看待
- 进入循环

	- 只从一个位置进入循环
	- 把初始化代码紧放在循环前面
	- 用while(true)表示无限循环

		- 或者for(;;)

	- 在适当的情况下多使用for循环
	- 在while循环更适用时，不要使用for循环

		- for循环头的位置保留给循环控制语句

			- 区分内务语句

- 处理好循环体

	- 用大括号把循环中的语句括起来
	- 避免空循环
	- 把循环内务操作要么放在循环的开始，要么放在循环的末尾
	- 一个循环只做一件事

		- 和子程序一样

- 退出循环

	- 设法确认循环能够终止
	- 使循环终止条件看起来很明显
	- 不要为了终止循环而胡乱改动for循环的下标

		- 循环计数器不由循环体控制

	- 避免出现依赖于循环下标最终值的代码

		- 使用变量

	- 考虑使用安全计数器

		- 增加了复杂度
		- 应用于关键的循环

- 提前退出循环

	- 考虑在while循环中使用break语句而不用布尔标记

		- 多个break条件放到一些独立的语句并靠近产生break的代码以减少嵌套

	- 小心那些有很多break散步其中的循环

		- 纽约电话系统停机故障

			- do-switch-if

	- 在循环开始处用continue进行判断

		- 避免if判断使循环体整体锁进
		- 循环中部或尾部改用if

	- 如果语言支持，使用带标号break结构

		- do-switch-if问题

	- 使用break和continue时要小心谨慎

		- 循环退出条件只写在一条语句

- 检查端点

	- 开始、中间和最终情况
	- off-by-one
	- 头脑模拟和手工运算

- 循环变量

	- 用整数或者枚举类型表示数组和循环的边界
	- 在嵌套循环中使用有意义的变量名来提高其可读性
	- 使用有意义的名字来避免循环下标串话

		- i,j,k问题

	- 把循环下标的变量的作用域限制在本循环内

		- 不要依赖于编译器实现

- 循环长度

	- 尽可能短，一目了然

		- 15-20行

	- 嵌套限制在3层以内

		- 子程序提取
		- 简化控制结构

	- 把长循环的内容移到子程序里
	- 让长循环格外清晰

		- 单一出口
		- 退出条件清晰无误

### 创建循环

- 由内而外

	- 字面量编写，缩进它，加循环，使用循环下标或计算表达式替换字面量
	- 详细步骤

		- 在注释里写下循环体需要执行的操作步骤
		- 注释转化为代码
		- 加入下标
		- 写出必要的初始化代码

### 循环与数组

- 基于特定语言

## 不常见的控制结构

### 多处返回

- 如果能增强可读性，那么就使用return

	- 如检测出错

- 用防卫子句来简化复杂的错误处理
- 减少每个子程序中return的数量

### 递归

- 使用递归

	- 问题的小部分容易解决
	- 问题的大部分很容易分解成众多的小部分时
	- 带来简单、优雅但是难懂的解

		- 比如走迷宫类型问题

- 技巧

	- 确认递归能够停止

		- 含有一条非递归的路径

	- 使用安全计数器防止出现无穷递归
	- 把递归限制在一个子程序内

		- 依靠脑力来管理位于一个子程序内的递归已经够困难了

	- 留心栈空间

		- 安全计数器上限
		- 留意内存消耗大的对象

	- 不要用递归去计算阶乘和斐波那契数列

		- 除了速度缓慢，并且无法预测运行期间的内存使用情况以外，用递归写出的子程序要比用循环写出的子程序更难理解
		- 使用递归之前考虑替代方案

			- 栈和循环

### goto

- 反对的观点

	- 很难安排好格式
	- 破坏编译器的优化特征
	- 运行速度慢
	- 代码更大
	- 违背代码应该严格自上而下运行的原则

- 支持的观点

	- 在分配资源、使用资源后再释放资源的子程序里非常有用

- 应用场景

	- 错误处理

		- goto
		- 状态变量替代
		- try finally替代

	- else子句中共享代码

		- 子程序替代

- 使用原则

	- 不直接支持结构化控制语句的语言里，goto可以模拟控制结构
	- 如果语言内置了等价的控制结构，那么就不要用goto
	- 衡量goto实际带来的性能提升
	- 除非要模拟控制结构，每个子程序只使用一个goto标号且尽量向前跳转
	- 确认goto标号都用到且不会产生执行不到的代码

### 观点

- 软件开发这一领域是在限制程序员对代码的使用中得到发展的
- 放弃注重灵活方便而忽视复杂度管理能力的结构

*XMind: ZEN - Trial Version*