# System Considerations

## 程序规模对构建的影响

### 交流和规模

- 交流路径指数增长
- 更大的项目要求采取一些组织技术来改善交流效率

	- 改善交流效率的常用方法是采用正式的文档

- 关键点

	- 减少交流中的问题
	- 促进交流

### 对错误的影响

- 随着项目规模的增大，通常更大一部分错误要归咎于需求和设计

	- 构建错误占错误总数的比例逐步下降但比重仍然很大

- 缺陷的数量也会随项目规模而变

### 对生产率的影响

- 最大因素

	- 小项目

		- 单个程序员的技巧

	- 项目规模和团队规模增大的项目

		- 组织方式

- 其他因素

	- 软件类型、人员素质、编程语言、方法论、产品复杂度、编程环境、工具支持、计算“代码行数”的方法、非程序的支持工作

- 小项目的生产率会比大项目高出2至3倍

### 对开发活动的影响

- 组织结构是多人项目成败的关键
- 活动比例

	- 随着项目规模的增大，构建活动在整个工作量中所占的比重将逐渐减小
	- 构建活动中，详细设计、编码、调试和单元测试会按比例增长
	- 工作量超线性增长的活动

		- 交流
		- 计划
		- 管理
		- 需求分析
		- 系统功能设计
		- 接口设计和规格说明
		- 架构
		- 集成
		- 消除缺陷
		- 系统测试
		- 文档生产

	- 有训练的编码实践、让其他开发者审查设计和代码、好的工具支持以及使用高级语言对大项目的价值是无法衡量的

- 软件类型

	- 最终软件的质量和复杂度是影响项目大小的关键因素
	- 类型

		- 程序

			- 只有开发者使用

		- 产品

			- 供给最初开发者以外的人员使用
			- 使用环境和开发环境不同
			- 需要提供文档

		- 软件系统

			- 一组能够结合起来工作的程序
			- 接口和集成

		- 系统产品

	- 没认识到以上软件类型在精致度和复杂度上的区别是导致估算出偏差的一个常见原因

- 方法论和规模

	- 成功的项目计划人员会明确为大型项目选择合适的策略
	- 协调的人员越多，所需要写的文档也就越正规
	- 先写计划的关键在于迫使你仔细考虑配置管理并且把你的计划向每个人解释
	- 以小的方法论为起点逐渐扩充，找出适量级的方法论

## 管理构建

### 鼓励良好的编码实践

- 设定标准

	- 减少分歧
	- 灵活的指导原则、一些建议
	- 人为制定

		- 精神领袖

- 技术

	- 给项目的每一部分分派两个人

		- 共同认可
		- 办法

			- 结对编程
			- 导师带学生
			- buddy-system

	- 逐行复查代码

		- 代码复查

			- 同事压力
			- 改善代码质量
			- 微妙方式促进小组的编码标准

	- 要求代码签名
	- 安排一些好的代码示例供人参考

		- 优良管理中的一个重要方面就是清楚地表达你的目标
		- 质量目标
		- 编码标准手册

			- 最佳代码清单

	- 强调代码是公有财产

		- 集体所有权

	- 奖励好代码

		- 所给予的奖励应该是程序员想要的
		- 只有非常出色的代码才应得到奖励

	- 一份简单的标准

		- 管理这不是技术尖子这一事实反而有助于阻止产生聪明的反而难以理解的代码

### 配置管理

- 定义

	- 系统化地定义项目工件和处理变化，以使项目已知保持其完整性的实践活动
	- 变更控制

		- 评估所提交的更改
		- 追踪更改
		- 保留系统在不同时间点的各历史版本

	- 软件配置管理

		- SCM

			- 避免过度控制

- 需求变更和设计变更

	- 遵循某些系统化的变更控制手续

		- 将变更放在“在对系统整体最为有利”的环境下进行考虑

	- 成组地处理变更请求

		- 整体看待

	- 评估每项变更的成本
	- 提防大量的变更请求

		- 需求、架构或者上层设计做得不够好的警报信号

	- 成立变更控制委员会或者类似机构

		- 任何可能改变软件的请求

	- 警惕官僚主义，但也不要因为害怕官僚主义而排斥有效的变更控制

		- 把所有的变更请求都作为缺陷记录在你的缺陷跟踪系统里
		- 形式

			- 变更控制委员会
			- 产品计划组或者作战委员会
			- 独裁

- 软件代码变更

	- 版本控制软件

		- 版本控制软件、缺陷跟踪和变更管理整合在一起

- 工具版本

	- 编译器、链接器、代码库

- 机器配置

	- 标准工作站磁盘映像

		- 开发工具和办公软件

- 备份计划

	- 脱机存储设备
	- 测试你的备份过程
	- 项目归档

		- 源代码
		- 编译器
		- 工具
		- 需求
		- 设计
		- 文档

### 评估构建进度表

- 评估项目的规模和完成项目所需的工作量是软件项目管理中最具挑战性的方面之一
- 评估方法

	- 项目规模和完成所需要工作量评估

		- 使用评估软件
		- 使用算法

			- Cocomo II

		- 聘请评估专家
		- 排练（walk-through）会议
		- 评估项目的每一部分，然后累加
		- 让成员评估各自的任务，然后再把各任务的评估值加起来
		- 参考以往项目的经验
		- 保留以往项目的评估，查看其准确度。用它来调整你的评估

	- 建立目标
	- 为评估留出时间，并且做出计划

		- 把评估当作一个“迷你项目”来做

	- 清楚地说明软件需求

		- 建筑师无法估算一座“相当大”的房子要花费几何一样

	- 在底层细节层面进行评估

		- 考察的越详细评估结果就会越准确

			- 大数定律，误差相互抵消

	- 使用若干不同的评估方法，并且比较其结果
	- 定期做重新评估

		- 项目越接近完成，评估的准确度应该越高

- 评估构建的工作量

	- 项目中构建活动占多大比例

		- 把你的组织项目经验记录下来

- 对进度的影响

	- 最大因素

		- 所开发软件的规模

	- 量化因素

		- 集中开发vs分散开发
		- 数据库大小
		- 满足项目需要的文档
		- 在解释需求方面的灵活度
		- 处理风险的积极程度
		- 语言经验和工作经验
		- 人员连贯性（流动性）
		- 平台稳定性
		- 过程成熟度
		- 产品复杂度
		- 程序员的个人能力
		- 所需的可靠度
		- 需求分析师的个人能力
		- 对重用的要求
		- 最新技术标准的应用程序
		- 存储限制
		- 团队凝聚力
		- 团队在该应用领域的经验
		- 团队在该技术平台上的经验
		- 应用程序自身的时间限制
		- 对软件工具的使用

	- 非量化因素

		- 需求开发者的经验和能力
		- 程序员的经验和能力
		- 团队的动力
		- 管理的质量
		- 重用的代码数量
		- 人员的流动性
		- 需求变更
		- 客户关系的质量
		- 用户对需求的参与度
		- 客户对此类应用的经验
		- 程序员对需求开发的参与程度
		- 计算机、程序与数据的分级安全环境
		- 文档量
		- 项目目标（进度、质量、可用性）

- 评估与控制

	- 落后

		- 希望自己赶上

			- 几乎不会发生
			- 越接近项目后期，延误和超支的现象就越严重

		- 扩展团队

			- Fred Brooks定律

				- 往一个已经落后的软件项目里加入人手只会使得它更加落后

					- 熟悉项目需要时间
					- 培训占用项目内成员时间
					- 人员增加导致交流复杂度和数量增加

			- 某些场合可行

				- 任务可分割

		- 缩减项目范围

			- 产品计划

				- 需求分级

			- 简化版本

				- 性能和资源占用放松

			- 重新评估非重要特性的开发时间

### 度量

- 原因

	- 任何一种项目特征都是可以用某种方法来度量的，而且总会比根本不度量好得多

		- 如果有些数据要用于科学实验，那么就必须进行量化

- 留心度量的副作用

	- 度量会对动机产生影响

		- 评价使非度量的工作被忽略

- 通过度量可以更加清晰的对项目某一环节进行了解

	- 有用的软件开发的度量环节

		- 规模
		- 整体质量
		- 缺陷跟踪
		- 可维护性
		- 生产率

	- 度量工具
	- 程序、类、子程序度量

		- 识别“局外人”子程序

			- 子程序质量

	- 不要一开始就收集全部可能得到的度量数据

### 把程序员当人看

- 程序员时间花费分配
- 性能差异和质量差异

	- 在编写的程序的质量、编写的程序的大小以及程序员生产率方面有着一个数量级的差异

- 个体差异

	- 程序员的经验与其代码质量和生产率之间没有什么关联

- 团队差异

	- 不同编程团队在软件质量和生产率上也存在着相当大的差异

		- 好的程序员倾向于聚集在一起，差的程序员也是一样
		- 3.5倍左右的差距，80%的贡献来源于20%的贡献者
		- 招聘和录用

			- 高品质和高生产力的程序员能迅速提供回报
			- 好的程序员倾向于聚到一起

- 信仰问题

	- 编程问题

		- 编程语言
		- 缩进风格
		- 大括号的摆放位置
		- 所用的集成开发环境
		- 注释风格
		- 效率和可读性的取舍
		- 对方法的选择

			- scrum、极限编程、渐进交付

		- 编程工具
		- 命名习惯
		- 对goto的使用
		- 对全局变量的使用
		- 度量，特别是有关生产力的度量，如每天编写的代码行数

	- 每一项都是程序员个人风格的反映
	- 考虑

		- 要清楚地知道你是在处理一个敏感的问题

			- 试探

		- 对这些领域要使用“建议”或者“指导原则”
		- 避免流露明显的意图

			- 格式美化工具
			- 代码复查

		- 让程序员们制定他们自己的标准
		- 没有必要在所有细节上都步调一致但不能牺牲代码质量

- 物理环境

	- 物理环境对生产率有着巨大的影响

		- 宽敞、安静、更为私密的办公室

	- 给每人10000到30000美元的基础建设投资能现住地体高生产力

		- 投入比强征暴敛更有助于提高生产率

- 额外

	- 以人为中心
	- 程序员参与办公室设计
	- 真诚地去了解他人

### 管理你的管理者

- 把你希望做什么的念头先藏起来
- 把做事情的正确方法传授给你的管理制

	- 持之以恒的工作

- 关注你的管理者的兴趣，按照他的真正意图去做，而不要用一些不必要的实现细节来分散其注意力

	- 对你工作的一种“封装”

- 拒绝按照你的管理者所说的去做
- 换工作
- 最佳的长远的解决方案是教育你的管理者

## 集成

### 定义

- 将一些独立的软件组件组合为一个完整系统

### 集成和构建次序都是重要的主题

### 重要性

- 编码、测试、调试
- 独立的行为
- 益处

	- 更容易诊断错误
	- 缺陷更少
	- 脚手架更少
	- 花费更少的时间获得第一个能工作的产品
	- 更短的整体开发进度表
	- 更好的顾客关系
	- 增强士气
	- 增加项目完成的机会
	- 更可靠的估计进度表
	- 更准确的现状报告
	- 改善代码质量
	- 较少的文档

### 集成频率

- 阶段式集成

	- 阶段

		- 设计、编码、测试、调试各个类

			- 单元开发

		- 将这些类组合为一个庞大的系统

			- 系统集成

		- 测试并调试整个系统

			- 系统瓦解

	- 缺陷

		- 问题会不可避免地大量浮现

			- 所有问题都是一下子出现

		- 出现问题的位置不确定

	- 大爆炸集成

- 增量集成

	- 步骤

		- 开发一个小的系统功能部件

			- 作为骨架

		- 设计、编码、测试、调试
		- 将这个新的类集成到系统骨架上，测试并调试“骨架和新类的结合体”

	- 益处

		- 易于定位错误

			- 易于查错

				- 要么在新组件中，要么是位于新组件和系统之间的连接中

			- 少量问题

				- 39%的错误是模块间的接口错误

		- 及早在项目里取得系统级的成果

			- 提升士气

		- 改善对进度的监控

			- 功能导向

		- 改善客户关系
		- 更加充分地测试系统中的各个单元
		- 能在更短的开发进度计划内建造出整个系统

			- 并行工作

	- 策略

		- 构建组件的顺序要合乎集成这些组件的顺序
		- 自顶向下

			- 特点

				- 类之间的接口必须仔细定义

			- 优点

				- 能相对较早地测试系统的控制逻辑

					- 顶部类

				- 项目早期就完成一个能工作的系统
				- 在完成底层的设计细节之前就开始编码

			- 缺点

				- 将棘手的系统接口演练留到最后才进行

					- 底层的问题冒上来影响顶层系统

						- 高层变动

				- 需要大量存根（stub）

					- stub可能包含错误

						- 错误来源不再限制在单个类

			- 实现

				- 竖直分块（vertical slice）

					- 分布件自上而下

		- 自底向上

			- 特点

				- 首先编写并集成位于层次体系底部的类

					- 需要test driver

			- 优点

				- 容易定位错误
				- 及早演练可能存在问题的系统接口

			- 缺点

				- 高层系统接口的集成工作留在最后

					- 高层设计问题影响过大

				- 要求集成之前完成整个系统的设计工作

					- 让底层细节驱动高层类的设计违反了信息隐藏原则和面向对象设计的原则

			- 实现

				- 分块集成法

		- 三明治集成

			- 特点

				- 首先集成层次体系顶部的高层业务对象
				- 然后集成底部的与设备接口的类和广泛使用的工具类
				- 最后开始集成中间层的类

			- 优点

				- 先集成比较棘手的类，能让项目所需的脚手架数量最少

		- 风险导向的集成

			- 困难部件优先集成法

				- 构建顺序类似三明治集成，但动机不同
				- 先鉴别各个类的风险等级

					- 顶层接口
					- 系统接口
					- 特殊算法
					- 特别性能要求

		- 功能导向的集成

			- 递归地使用增量集成策略

				- 将小的代码块集成为功能，将功能集成为系统

			- 骨架+功能树
			- 优点

				- 不用脚手架

					- 除了骨架

				- 每个新集成的功能都增加了系统的功能性

					- 方便用户评估

				- 与面向对象设计能很好地协同工作

			- 缺点

				- 降低了新错误的来源的确定程度

					- 集成的功能通常不止一个类

			- 实现

				- 先集成某些底层的代码，之后才能集成某些重要的功能

		- T型集成

			- 解决自顶向下和自底向上的问题
			- 及早开发并集成竖直块（vertical slice）
			- 从头到尾地演练系统并找出系统设计所做的假设中的全部重要问题
			- 结合风险导向的集成和功能导向的集成

	- 集成方法也是启发式的

### Daily Build与冒烟测试

- 优点

	- 降低了低质量的风险

		- 防止系统恶化

	- 便于诊断缺陷
	- 提高士气
	- 使一些看不见的工作浮出水面

		- 有规则地将工作均匀分担在项目的整个生命周期中

- daily build

	- 每日构建

		- 同步脉冲

	- 检查失败的build

		- 建立一套质量等级

			- 好的build

				- 成功地编译所有文件、库和其他组件
				- 成功地链接所有文件、库和其他组件
				- 通过冒烟测试

	- 每天进行冒烟测试

		- 从头到尾地演练整个系统

			- 暴露主要的问题
			- 预防产品质量恶化和集成问题蔓延

	- 让冒烟测试与时俱进

		- 随着系统开发，冒烟测试变得更加彻底

	- 将daily build和冒烟测试自动化
	- 成立build小组

		- 看护daily build并让冒烟测试保持更新

	- 当修订有意义时才加入build,但别等太久

		- 频繁的集成迫使你将单一功能的构建分为若干阶段进行

			- 减少集成风险
			- 改善项目状况的能见度
			- 改善可测试性

	- 代码添加到系统之前进行冒烟测试

		- 开发人员私有build

	- 为即将添加到build的代码准备一块暂存区
	- 惩罚破坏build的人

		- 保持build的健康是项目优先级最高的事情之一
		- 破坏build应该是异常情况而不是惯例

	- 在早上发布

		- 测试人员当天就能测试新鲜的build

			- build延迟导致测试人员很晚启动测试，挫伤士气

		- 每天快结束时测试对团队过于刻薄，浪费了时间，得不偿失

	- 即使有压力，也要进行daily build和冒烟测试

		- 高压力下项目混乱度（熵）更高
		- 强调纪律

- 应用

	- 近代历史上最复杂的软件项目成功地应用了daily build

		- windows 2000

			- 5000万行代码
			- 几万个源文件
			- build一次19小时

	- 项目越大，增量集成就越重要

- 持续集成

	- 持续集成并不优于每天集成

		- 让代码短暂脱离同步的状态是有价值的

### 其他

- 物理设计

	- 文件、目录、程序库等层次结构对开发团队建造软件的能力有着重大影响

- 渐进主义

	- 为改变而做设计

*XMind: ZEN - Trial Version*