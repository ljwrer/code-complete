# Code Improvement

## 软件质量概述

### 软件质量的特性

- 外在特征

	- 正确性
	- 可用性
	- 效率
	- 可靠性

		- 平均无故障时间

	- 完整性

		- 访问限制

	- 适应性

		- 执行环境

	- 精确性
	- 健壮性

- 内部特征

	- 可维护性
	- 灵活性
	- 可移植性
	- 可重用性
	- 可读性
	- 可测试性
	- 可理解性

		- 内在一致性

- 要让所有特性都能表现得尽善尽美绝无可能
- 内在特性和外在特性相互影响

### 改善软件质量的技术

- 软件质量目标

	- 明确定义

- 明确定义质量保证工作
- 测试策略

	- 与产品需求、架构以及设计相关联

- 软件工程指南

	- 控制软件技术特性
	- 应用

		- 问题定义
		- 需求分析
		- 架构设计
		- 构建
		- 系统测试

- 非正式技术复查

	- review

		- 桌面检查
		- 代码走查

- 正式技术复查

	- 质量门

		- 检查某一阶段的产品是否已经具备了进入下一阶段所要求的质量
		- 判断需求或者架构是否已经足够的好

- 外部审查
- 开发过程

	- 对变更进行控制的过程

		- 有效的管理

	- 结果的量化

		- 正确性、可用性以及效率

	- 制作原型

- 设置目标

	- 明确质量目标

### 相对效能

- 组合运用

	- 极限编程

- 找出缺陷的成本

	- 检查比测试的成本更小

- 修正缺陷的成本

	- 缺陷存在时长影响修复成本
	- 检查代码能同时修复问题

- 建议

	- 对所有需求、架构以及系统关键部分的设计进行正是检查
	- 建模或者创建原型
	- 代码阅读或检查
	- 执行测试

### 时机

- 早期阶段

### 普遍原理

- 改善质量以降低开发成本

	- 减少花在代码返工上的时间

		- 耗时：调试以修正那些无法正常工作的代码

	- 每人每天10到50行最终交付代码

- 编写无缺陷软件并不一定花更多的时间
- 与编码-测试-调试相比，先进的软件质量计划可能更省钱

	- 缺陷更少，开发时间更短，成本更低
	- 没有付出更多，只是对资源进行重新分配

- 软件质量是面向过程的，与制造业面向结果不一样

## 协同构建

### 将展示工作的过程正式化

### 实践概要

- 包括

	- 结对编程
	- 正式检查
	- 非正式技术复查
	- 文档阅读

- 工作中开发人员总会对某些错误点视而不见
- 首要目的是改善软件质量

	- 缩短开发周期
	- 降低开发成本
	- 捕获错误比测试效能更高，错误类型也不同于测试
	- 让人们意识到他们的工作会被复查

- 有利于传授公司文化以及编程专业知识

	- 程序设计主观方面的回馈
	- 复查提供了一个技术交流平台

		- 培养新人以提高其代码质量的好机会

- 集体所有权

	- 代码属于团队

		- 多人检查，协力编写
		- 个人离开项目影响变小
		- 缺陷修正周期变短

			- 团队中任何一员都可以修正

	- 交叉覆盖结束复查，结对编程，轮换指派修正任务

- 构建前后都应保持协作

	- 适用于评估、计划、需求、架构、测试以及维护工作等阶段

### 结对编程

- 关键

	- 准则

		- 用编码规范来支持结对编程

			- 风格标准化

		- 不要让结对编程变成旁观
		- 不要强迫在简单的问题上使用结对编程

			- 白板+独立编程
			- 部分工作采用结对编程

		- 有规律地对结对人员和分配的工作任务进行轮换
		- 鼓励双方跟上对方的步伐
		- 确认两人都能看到显示器
		- 不要强迫程序员与自己关系紧张的人组对
		- 避免新手组合
		- 指定一个组长

	- 好处

		- 压力之下状态更佳
		- 改善代码质量

			- 代码可读性和可理解性倾向于团队最优秀程序员水平

		- 缩短进度时间表
		- 享受协同构建的好处

			- 传播公司文化
			- 指导初级程序员
			- 培养集体归属感

### 正式检查

- 结果

	- 去除产品中70%到85%的缺陷

		- 占用10%-15%的项目预算，降低项目的整体成本

	- 评估进度

- 人员角色

	- 主持人

		- 技术上面必须能够胜任
		- 能理解设计和代码的细节

	- 作者

		- 表达自己

	- 评论员

		- 找出缺陷

	- 经理

		- 最好不要参与
		- 容易由技术问题转换到行政问题
		- 准备一份详细报告让经理了解情况

	- 详查的结果都不应当作为员工表现的评估标准
	- 对员工的表现评估应当基于最终产品，而不是尚未完成的工作
	- 人数

		- 不应少于三人，需要单独的主持人、作者和评论员
		- 限制在六人左右

- 一般步骤

	- 计划

		- 主持人提供打印带有行号的注意核对表

			- 便于快速标识错误

	- 概述

		- 谨慎使用

			- 代码应该自我表达

	- 准备

		- 独立详查

			- 应用程序

				- 500行/h

			- 系统级代码

				- 125行/h

		- 每个评论员赋予某一特定视角

			- 赋予待详查场景

	- 详查会议

		- 主持人挑选出除作者之外的某个人阐述设计或阅读代码

			- 包含每个分支

		- 讨论在确定错误时停止
		- 保留以前的记录
		- 150-200行/h非空非注释代码
		- 不讨论解决方案，把注意力保持在识别缺陷上

	- 详查报告

		- 收集数据以证明其存在的必要性

	- 返工
	- 跟进

		- 评论员重新详查整个工作成果

	- 第三个小时会议

		- 非正式会议讨论解决方案

	- 细调

		- 对详查过程精雕细琢
		- 更新适应自身需求的核对表

			- 限制在一页以内

- 自尊心

	- 详查过程应该是正面的

		- 团队参与使程序得到了明显改善
		- 对所有参与者都是一个学习的过程

	- 作者来负责决定如何处理缺陷

		- 享受寻找缺陷的乐趣

- 总结

	- 自我优化

		- 正式的反馈循环

	- 详查过程展示了改模型的最高级别的状况，这一过程使系统化和可重复的，并且使用了量化的反馈方法来自我改进

### 其他

- 走查

	- 特点

		- 由作者主持
		- 焦点在技术事宜上
		- 参与者通过阅读设计或代码进行准备
		- 提供技术交流的机会
		- 持续30-60分钟
		- 重点在于检测错误，而非修正
		- 经理不会参加
		- 概念灵活

	- 对代码进行同事互查的成本极端的高
	- 采用时机

		- 复查团队较大
		- 有其他组织的评审员参与

- 代码阅读

	- 定义

		- 两到三个人参与

			- 鼓励竞争

		- 独立阅读代码

			- 4000行左右，1天1000行

		- 与代码作者开会讨论

			- 1-2小时
			- 集中在发现的问题上而不用遍历代码

	- 特点

		- 代码阅读更多地关注对代码进行的独立复查，而不是关注会议本身
		- 时间更多分布在代码阅读而非会议上
		- 适用于人员地理位置分散的情况
		- 90%的缺陷都是在复查会议做准备的时候发现的

- 公开演示

	- 政府项目常见
	- 管理层复查而非技术复查
	- 通常不会改善软件品质

## 开发者测试

### 概述

- 测试方法

	- 单元测试
	- 组件测试
	- 集成测试
	- 回归测试
	- 系统测试

		- 安全、性能、时序

- 分类

	- 黑盒测试
	- 白盒测试

- 测试是一种检查错误的方法，而调试意味着错误已经被发现

### 扮演的角色

- 测试很多时候是软件质量规划中的唯一组成部分（不幸）
- 煎熬的理由

	- 测试的目的与其他开发活动背道而驰

		- 找出错误、弄垮软件

	- 测试永远不可能彻底证明程序中没有错误
	- 测试本身并不能改善软件的质量
	- 测试时要求你假设会在代码里面找到错误

- 用时

	- 开发者测试应该占整个项目时间的8%-25%，不包含调试时间

- 开发者测试的结果

	- 评估产品的可靠性
	- 指导对软件的修正
	- 缺陷记录有利于归纳出程序中最常见的错误类型

		- 培训课程
		- 指引技术复查活动
		- 设计未来的测试用例

- 构建中测试

	- 进行彻底的单元测试

		- 代码覆盖率

### 推荐方法

- 确保

	- 对每一项相关的需求进行测试

		- 需求阶段计划好

	- 对每一个相关的设计关注点进行测试，以确保设计已经被实现
	- 用基础测试来扩充针对需求和设计的详细测试用例
	- 使用一个检查表记录迄今为止所犯以及过去项目所犯的错误类型

- 测试先行

	- 优势

		- 不比之后多花功夫，只是调整一下测试用例编写活动的工作顺序而已
		- 可以更早发现缺陷，同时也更容易修正他们
		- 迫使你在开始写代码之前至少思考一下需求和设计
		- 更早把需求问题暴露出来
		- 仍然可以最后再进行测试

	- 测试先行的编程是过去十几年中所形成的最有用的软件开发实践之一

- 局限性

	- 开发者倾向于干净测试

		- 肮脏测试应是干净测试的5倍

	- 开发者对覆盖率有过于乐观的估计
	- 开发者测试往往会忽略一些更复杂的测试覆盖率类型

		- 100%语句覆盖率=>100%分支覆盖率

	- 补充独立测试和协同构建技术

### 测试技巧

- 不完整测试

	- 进行完全测试实际上是不可能的

- 结构化的基础测试

	- 需要测试程序中的每一条语句至少一次

		- 计算程序路径总数，开发出通过每条路径的最少数量的测试用例
		- 保持子程序和布尔表达式简短能让程序更易于测试

- 数据流测试

	- 代码中有一半是数据声明和初始化
	- 数据状态

		- 已定义

			- 初始化未使用

		- 已使用
		- 已销毁

			- 已取消引用

		- 已进入

			- 控制流已进入子程序还未使用的变量

				- 子程序开始处初始化的变量

		- 已退出

			- 对变量产生影响之后，控制流立即退出子程序

				- 返回的变量

	- 数据状态组合

		- 已定义-已定义

			- 定义两次，危险！

		- 已定义-已退出

			- 参数或全局变量
			- 局部变量不应该在定义后不使用就退出

		- 已定义-已销毁

			- 该变量对程序没有意义

		- 已进入-已销毁

			- 参数或全局变量
			- 局部变量未定义或使用，不需要销毁

		- 已进入-已使用

			- 参数或全局变量
			- 局部变量应在使用之前被定义

		- 已销毁-已销毁

			- 一个变量不应该销毁两次

		- 已销毁-已使用

			- 不应该使用已销毁的变量

		- 已使用-已定义

			- 检查变量在使用之前是否定义过

	- 数据流测试

		- 检查反常的数据状态
		- 对所有可能路径的定义-使用路径进行测试

			- 彻底程度

				- 所有的定义

					- 每一行代码进行测试已包括此情况

				- 所有已定义-已使用的组合

					- 更强的策略

		- 首先进行结构化的基础测试，然后添加完整的已定义-已使用数据流测试所需的用例

	- 等价类划分

		- 减少所需用例数量

	- 猜测错误

		- 边界值分析

			- off-by-one
			- 复合边界值

				- 边界条件涉及到互相关联的多个变量

		- 坏数据

			- 数据太多
			- 数据太少（或没有）
			- 错误的数据（无效数据）
			- 长度错误的数据
			- 未初始化的数据

		- 好数据

			- 正常的情形——大路正中间，所期望的值
			- 最小的正常局面
			- 最大的正常局面
			- 与就数据的兼容性

				- 版本间的连续性是回归测试的基础

		- 采用容易手工检查的测试用例

### 典型错误

- 类错误

	- 20%的子程序占用了80%的开发成本
	- 高缺陷率子程序的成本异常高昂

		- 错误并非平均地分布在所有的子程序里面，而是集中在少数几个子程序里面

	- 子程序开发成本昂贵带来的影响显而易见

		- 提高质量就能缩短开发周期，同时降低开发成本

	- 避免维护惹人烦厌的子程序同样具有明显的重大意义

- 错误分类

	- 大多数错误的影响范围相当有限
	- 很多错误发生在构建的范畴之外

		- 缺乏应用领域知识
		- 频繁变动且相互矛盾的需求
		- 以及沟通和协调的失效

	- 大多数的构建期错误是编程人员的失误造成的

		- 95%

	- 笔误（拼写错误）是一个常见的问题根源
	- 错误的理解设计
	- 大多数错误都很容易修正
	- 总结所在组织中对付错误的经验

		- 借助工具

			- 一个良好的开始就是评估你的开发方法

- 占比

	- 构建总会出现大量的错误
	- 修正单个构建错误的成本可能较低，但没有证据证明总体成本比较低
	- 修正构建错误的绝对值来看仍然是高昂的

- 发现错误

	- 业界：1000行1-25个
	- 微软

		- 协同开发/代码阅读 + 独立测试

			- 内部测试程序

				- 1000行10-20个

			- 已发布产品

				- 1000行0.5个

	- 净室开发

		- 形式化开发方法，同事复查，统计测试

			- 内部测试程序

				- 1000行3个

			- 已发布产品

				- 1000行0.1个

	- TSP(团队软件开发过程)

		- 训练开发人员把避免缺陷放在第一位

			- 1000行0.06个

		- 开发高质量的软件比开发低质量软件然后修正的成本要低廉

			- 几乎没人将时间投入到调试中

- 测试本身的错误

	- 减少错误量

		- 检查你的工作

			- 以开发代码的谨慎态度

		- 开发软件的时候就要计划好测试用例
		- 保留你的测试用例

			- 回归测试

		- 将单元测试纳入测试框架

### 测试支持工具

- 测试脚手架

	- 哑类

		- 模仿对象（mock object）

			- faker.js

		- 桩函数（stub routines）

			- sihon.js

	- 驱动函数

		- 测试夹具

			- mocha

	- 哑文件

		- 真实文件的小尺寸版本
		- 构成和全尺寸文件一模一样
		- 可以轻易断定文件本身没有错误
		- 使使用文件的错误都能暴露出来

	- 现成测试框架提供的脚手架功能(JUnit,CppUnit,NUnit)

		- 在类文件中添加main()子程序测试这个类
		- 通过预处理器排除
		- 位于底部，不干扰视线

- diff工具

	- 自动对比实际输出与期望输出的工具

- 测试数据生成器

	- faker.js
	- 测试更彻底

		- 可以产生意想不到的、不寻常的测试数据组合

	- 体现模块化设计优势

- 覆盖率监视器

	- istanbul

- 数据记录器、日志记录器

	- 自动裁剪记录长度

- 符号调试器

	- 在调试器中走查代码
	- 优秀的调试器是了解你所用语言的一个很好的工具

- 系统干扰器

	- 内存填充

		- 确认所有变量都已经初始化

			- 0填充
			- 0xCC填充

	- 内存抖动

		- 多任务系统

			- 依赖相对位置的数据而非绝对位置

	- 选择性内存失败

		- 动态分配内存的复杂程序

	- 内存访问检查（边界检查）

		- 寻找未初始化的或者悬空的指针

- 错误数据库

	- 即是管理工具也是技术工具

### 改善测试过程

- 有计划的测试

	- 在待测试项目开始之初就拟定测试计划
	- 与设计和编码平起平坐
	- 使测试过程可重复

- 重新测试（回归测试）

	- 确保软件没有倒退

- 自动化测试

	- 手动测试发生错误的几率与被测代码中错误存在的几率有的一拼
	- 好处

		- 发生错误的几率比手动测试要小
		- 一旦一个测试自动化了，很容易在项目的剩余部分继续实施自动化
		- 如果测试是自动进行的，那么就可以频繁地运行

			- 测试自动化是各种测试实践的基础

				- daily build
				- 冒烟测试
				- 极限编程

		- 自动化测试可以提高问题刚产生就被发现的可能性
		- 为大规模代码修改提供了一张安全网
		- 对新的、不稳定的技术环境当中特别有价值

			- 提早稀释了环境对系统的影响，而非事后补救

	- 工具

		- 脚手架
		- 生成输入
		- 捕获输出
		- 比较实际输出与预期输出

### 保留测试记录

- 记录数据

	- 缺陷的管理方面描述（报告日期、报告人、描述或标题、生成编号以及修正错误的日期）
	- 问题的完整描述
	- 复现错误所需要的步骤
	- 绕过改问题的建议
	- 相关的缺陷
	- 问题的严重程度

		- 致命的、严重的或者表面的

	- 缺陷根源：需求、设计、编码还是测试
	- 对编码缺陷的分类：off-by-one错误、错误赋值、错误数组下标以及子程序调用错误
	- 修正错误所改变的类和子程序
	- 缺陷所影响的代码行数
	- 查找该错误所花的小时数
	- 修正错误所花费的小时数

- 分析

	- 项目是向着更健康还是更糟糕的趋势发展
	- 内容

		- 每个类或子程序的缺陷数目

			- 按糟糕程度排序

				- 对这个数字进行归一化处理

		- 发现一个错误平均所需要花费的测试时间
		- 每个测试用例所发现缺陷的平均数
		- 修正一个缺陷的花费的平均编程时间
		- 全部测试用例的代码覆盖率
		- 在各个严重级别中处理缺陷的数量

- 个人测试记录

	- 你最常犯的错误
	- 记录编写代码、测试代码以及修正代码所花费的时间

### 在检测错误方面，协同开发的成效至少与测试相当

## 调试

### 概述

- 迫不得已时采用的手段
- 调试效率差异巨大

	- 提高软件质量能够减少开发成本

- 让你有所收获的缺陷

	- 理解你正在编写的程序
	- 明确你犯了哪些类型的错误
	- 从代码阅读者的角度分析代码质量
	- 审视自己解决问题的方法
	- 审视自己修正缺陷的方法

- 效率低下的调试方法

	- 凭猜测找出缺陷
	- 不要把时间浪费在理解问题上
	- 用最唾手可得的方式修正错误
	- 迷信式调试

### 寻找缺陷

- 科学的调试方法

	- 将错误状态稳定下来
	- 确定错误的来源

		- 收集产生缺陷的相关数据
		- 分析所收集的数据，并构造对缺陷的假设
		- 确认怎样证实或证伪这个假设，可以对程序进行测试或是通过检查代码
		- 按照第三步确定的方法对假设作出最终结论

	- 修补缺陷
	- 对所修补的地方进行测试
	- 查找是否还有类似的错误

- 建议

	- 如果在寻找缺陷的时候遇到了麻烦，很可能是因为你的代码写得不好
	- 在构造假设是考虑所有的可用数据

		- 保持不断对假设进行提炼

	- 提炼产生错误的测试用例

		- 在更大的范围内调整参数

	- 在自己的单元测试族中测试代码
	- 利用可用的工具

		- 交互式调试器
		- 吹毛求疵型编译器
		- 内存检查工具
		- 带有语法提示的编辑器

	- 采用多种不同的方法重现错误

		- 错误常常是由多种因素交织产生

	- 用更多的数据生成更多的假设
	- 利用否定性测试用例的结果
	- 对可能的假设尝试头脑风暴

		- 最初不用去分析

	- 在桌上放一个记事本，把需要尝试的事情逐条列出
	- 缩小嫌疑代码的范围

		- 二分法注释

	- 对之前出现过缺陷的类和子程序保持警惕
	- 检查最近修改过的代码
	- 扩展嫌疑代码的范围

		- 二分查找法

	- 增量式集成
	- 检查常见缺陷
	- 同其他人讨论问题

		- 忏悔式调试

	- 抛开问题，休息一下

- 蛮力调试

	- 在使用“快速肮脏调试法”的时候设置一个时间上限

		- 投机心理

- 语法错误

	- 不要过分信任编译器信息中的行号
	- 不要迷信编译器信息
	- 不要轻信编译器的第二条信息
	- 分而治之
	- 找出所有配对的注释或者引号

### 修正缺陷

- 建议

	- 在动手之前先要理解问题
	- 理解程序本身，而不仅仅是问题
	- 验证对错误的分析
	- 放松一下

		- 压力将会使程序员更倾向于采用随机测试查找问题

	- 保存最初的源代码
	- 治本，而不是治标
	- 修改代码时一定要有恰当的理由

		- 不要随机修改代码

			- 0，-1，1
			- > >= < <=

	- 一次只做一个改动
	- 检查自己的改动
	- 增加能暴露问题的单元测试
	- 搜索类似的缺陷

### 调试中的心理因素

- 如果你既编写代码又对它进行调试，你不得不让自己的大脑不停地在流畅的创造性设计和刻板的调试过程之间疲于奔命
- 心理取向的影响

	- 证明养成良好的编程习惯的重要性
	- 当发现错误时，程序员对于需要检查的程序部分的选择

- 心理距离在调试中的作用

	- 警惕那些没有足够心理距离的相似变量名或子程序名

### 调试工具

- 源代码比较工具
- 编译器的警告消息

	- 将编译器的警告级别设置为最高级，尽可能不放过任何一个警告，然后修正编译器所报告的全部错误

		- 编写编译器的人对你所使用的语言的了解要远远胜过你自己

	- 用对待错误的态度来处理警告
	- 在项目组范围内使用统一的编译设置

- 增强的语法检查和逻辑检查

	- 执行剖测器

		- 发现隐藏错误

- 测试框架/脚手架
- 调试器

	- 断点，回溯，数据检查
	- 查看调用链，修改环境参数
	- 在系统一级上工作而不是应用程序一级
	- 最有效的组合是良好的思维加上优秀的调试器

## 重构

### 现实

- 即使是管理完善的项目，每个月都有大约1/4的需求发生变化
- 现在的开发方法增强了代码在构造阶段中改变的潜力

### 软件演化的类型

- 区分软件演化类型的关键

	- 程序的质量在这一过程中是提高了还是降低了
	- 演化是源于程序构建过程中的修改还是维护过程中的修改

		- 构建过程高度动态

- 基本准则

	- 演化应当提升程序的内在质量

### 简介

- 理由

	- 代码重复

		- 复制粘贴即设计之谬

	- 冗长的子程序

		- 很少会需要用到长度超过一个屏幕的子程序
		- 改善系统的方法之一就是提升其模块性

	- 循环过长或嵌套过深
	- 内聚性太差的类
	- 类的接口未提供一致的抽象

		- 随时间推移一致性减弱

	- 拥有太多参数的参数列表
	- 类的内部修改往往被局限于某一部分

		- 拆分

	- 变化导致对多个类的相同修改

		- 难于实现但值得努力的目标

	- 对继承体系的同样修改
	- case语句需要做相同的修改
	- 同时使用的相关数据并未以类的方式进行组织
	- 成员函数使用其他类的特征比使用自身类的特征还要多
	- 过多使用基本数据类型
	- 某个类无所事事
	- 一系列传递流浪数据的子程序

		- 子程序接口的抽象概念是否相同

	- 中间人对象无事可做
	- 某个类同其他类过于亲密

		- 包括派生类了解基类中过多的东西

	- 子程序命名不恰当

		- 立刻着手修改

	- 数据成员被设置为公用

		- 模糊接口和实现之间的界限

	- 某个派生类仅使用了基类的很少一部分成员函数

		- 派生类不是出于逻辑上的派生关系

			- is->has转换

	- 注释被用于解释难懂的代码

		- 不要为拙劣的代码编写文档，应当重写代码

	- 使用了全局变量

		- 早期修订是提升代码质量的最佳时机

	- 对子程序调用前使用了设置代码（setup code），或在待哦用使用了收尾代码（takedown code）

		- 子程序是否体现了正确的抽象

	- 程序中的一些代码似乎是将来的某个时候才会用到（超前设计）

		- 需求定义不完备
		- 无法预见需求的所有复杂脉络
		- 未来程序员并不知道自己手中的代码是超前设计的
		- 画蛇添足，增加了程序的复杂性

- 拒绝的理由

	- 成为代码做了任何修改的同义词

		- 深思熟虑的修改必将成为代码质量稳步提升之关键且能避免如今随处可见的代码因质量不断下降而最终灭亡的趋势

### 特定的重构

- 数据级的重构

	- 用具名常量替代神秘数值
	- 使变量的名字更为清晰且传递更多信息
	- 将表达式内联化
	- 用函数来代替表达式
	- 引入中间变量
	- 用多个单一用途变量代替某个多用途变量
	- 在局部用途中使用局部变量而不是参数
	- 将基础数据类型转化为类

		- 额外的功能，如数据检查

	- 将一组类型码（type codes）转化为类或枚举类型
	- 将一组类型码转化为一个基类及相应派生类
	- 将数组转换成对象

		- 当数组中元素类型不同时

	- 把群集（collection）封装起来

		- 只读并提供添加和删除元素的子程序

	- 用数据类来代替传统记录

		- 错误检查、持久化

- 语句级的重构

	- 分解布尔表达式
	- 将复杂的布尔表达式转化为命名准确的布尔函数
	- 合并条件语句不同部分中的重复代码片段
	- 使用break或return而不是循环控制变量
	- 在嵌套的if-then-else语句中一旦知道答案就立即返回，而不是去赋一个返回值
	- 用多态来替代条件语句（尤其是重复的case语句）
	- 创建和使用null对象而不是去检查空值

- 子程序级重构

	- 提取子程序或者方法
	- 将子程序的代码内联化
	- 将冗长的子程序转换为类
	- 用简单算法替代复杂算法
	- 增加参数
	- 删除参数
	- 将查询操作从修改操作中独立出来
	- 合并相似的子程序，通过参数区分它们的功能
	- 将行为取决于参数的子程序拆分开来
	- 传递整个对象而非特定成员
	- 传递特定成员而非整个对象
	- 包装向下转型的操作

		- 子程序返回对象时应当返回已知精确的对象类型

- 类实现的重构

	- 将值对象转化为引用对象
	- 将引用对象转化为值对象
	- 用数据初始化代替虚函数

		- 初始化时设置

	- 改变成员函数或成员数据的位置

		- 考虑对继承体系做出修改

			- 减少派生类的重复工作

				- 子程序上移到基类
				- 成员上移到基类
				- 构造函数的部分代码上移到基类

			- 派生类特殊化的工作

				- 将子程序下移到派生类
				- 将成员下移派生类
				- 将构造函数下移到派生类

	- 将特殊代码提取为派生类
	- 将相似的代码结合起来放置到基类中

- 类接口的重构

	- 将成员函数放到另一个类中
	- 将一个类变成两个
	- 删除类
	- 去除委托关系
	- 去掉中间人
	- 用委托代替继承
	- 用继承代替委托
	- 引入外部成员函数

		- 客户类中创建新的成员函数

	- 引入扩展类

		- 创建新类

			- 派生或者包装

	- 对暴露在外的成员变量进行封装
	- 对于不能修改的类成员、删除相关的set成员函数
	- 封装不使用的成员函数
	- 合并那些实现非常类似的基类和派生类

- 系统级重构

	- 为无法控制的数据创建明确的索引源

		- GUI数据映射

	- 将单向的类联系改为双向的类联系
	- 将双向的类联系改为单向的类联系
	- 用Factory Method模式而不是简单地构造函数

		- 类型码

	- 用异常处理错误代码，或者做相反方向的变换

### 安全的重构

- 软件外部脑科手术
- 方法

	- 保存初始代码
	- 重构的步伐请小些
	- 同一时间只做一项重构
	- 把要做的事情一条条列出来
	- 设置一个停车场
	- 多使用检查点
	- 利用编译器警告信息
	- 重新测试
	- 增加测试用例
	- 检查对代码的修改

		- 第一次修改容易出错
		- 单行代码修改检查

	- 根据重构风险级别来调整重构方法

- 不宜重构的情况

	- 不要把重构当做先写后改的代名词

		- 重构的含义在不影响程序行为的前提下改进可运行的代码

	- 避免用重构代替重写

### 重构策略

- 受制于收益递减定律
- 策略

	- 在增加子程序时进行重构
	- 在添加类的时候进行重构
	- 在修补缺陷的时候进行重构
	- 关注易于出错的模块
	- 关注高度复杂的模块
	- 在维护环境下，改善你手中正在处理的代码
	- 定义清楚干净代码和拙劣代码之间的边界，然后尝试把代码移过这条边界

		- 现实世界的混乱源于复杂的业务规则或软硬件接口
		- 使旧的系统的代码靠近当前的代码规范，引入理想世界

### 要点

- 软件演化的首要法则就是代码演化应当提升程序的内在质量
- 关注标志着代码需要重构的众多警告或代码臭味
- 开发阶段的重构是提升程序质量的最佳时机

## 代码调整策略

### 策略层面上的性能问题

### 概述

- 质量特性和性能

	- 性能同代码速度之间存在着很松散的联系
	- 过分强调速度，程序的整体性能（表现）常常不升反降

- 性能和代码调整

	- 效率

		- 处理速度
		- 资源占用

	- 方向

		- 程序需求

			- 解决确实需要解决的问题

		- 程序的设计

			- 设计架构时优先考虑整体性能
			- 为单个的子系统、特征和类设置要达到的资源占用目标

				- 最终性能可预测
				- 目标描述明确
				- 促进效率的提升，与其他因素结合

		- 类和子程序的设计

			- 选择合适的数据结构和算法

				- 影响内存占用和执行速度

		- 同操作系统的交互
		- 代码编译
		- 硬件
		- 代码调整（Tuning）

			- 较小规模的修改

	- 累乘性能改进

### 简介

- 高效的代码并不一定就是更好的代码
- Pareto法则

	- 80/20法则
	- 集中火力来对付占用了绝大部分资源的少量代码
	- 完美是优良之大敌

- 无稽之谈

	- 错误观点

		- 在高级语言中。减少代码的行数就可以提升所产生的机器代码的运行速度或是减少其资源占用
		- 特定运算可能比其他的快，代码规模也较小

			- 执行环境绑定

		- 应当随时随地进行优化

			- 忙于微观范围的优化而对整个系统全局性的重要优化视而不见
			- 麻烦

				- 无法在程序所有功能运转之前确定性能瓶颈
				- 顾此失彼
				- 干扰对其他程序目标的理解和判断

			- 不成熟的优化的主要缺陷在于它缺乏前瞻性
			- 在优化过程中建立一种全局观点

		- 程序的运行速度同其正确性同等重要

	- 过早优化威胁软件的整体质量

- 何时调整代码

	- 在程序已经完成并正确之后，再去检查系统的性能

- 编译器优化

### 蜜糖和哥斯拉

- 常见的低效率之源

	- 输入/输出操作

		- 除非程序对空间占用非常敏感，否则数据都应放在内存里面
		- 内存>本地文件>网络文件

	- 内存分页
	- 系统调用

		- 编写自己的服务实现
		- 避免进入系统
		- 尝试同系统软件商沟通

	- 解释型语言
	- 错误

### 性能测量

- 性能问题的很多方面都是违反直觉的
- 经验对性能优化也没有太大的帮助
- 性能测量应当精确

	- 使用cpu时钟而不是日期时钟

### 反复调整

### 代码调整方法总结

- 设计良好的代码，易于理解和修改
- 如果性能很差

	- a.保存代码的可运行版本
	- b.对系统进行分析测量，找出热点
	- c.判断性能拙劣是否源于设计、数据类型或算法商的缺陷，确定是否应该做代码调整，如果不是回到第一步
	- d.对步骤c中所确定的瓶颈代码进行调整
	- e.定量测量
	- f.如果没有改进,恢复到a

- 重复步骤2

*XMind: ZEN - Trial Version*