# Code

## 软件构建中的设计

### 设计中的挑战

- 你必须首先把这个问题“解决”一遍以便能够明确地定义它，然后再次解决该问题
- 犯错正是设计的关键所在
- 设计是一个启发式过程

### 关键的设计概念

- 管理复杂度

  本质属性是一件事物必须具备、如果不具备就不再是该事物的的属性。

	- 不断的去发觉错综复杂、相互连接的整套概念的所有细节
	- 没有睡的大脑能容得下一个现代的计算机程序（Dijkstra 1972）
	- 减少任一时间所要考虑的程序量

		- 分解多个子系统
		- 设计对象关系与包

- 理想的设计特性

	- 最小复杂度

		- 简单、易于理解

	- 易于维护

		- self-explanatory

	- 松散耦合

		- 关联最小化

	- 可扩展性

		- 稳定的底层结构

	- 可重用性
	- 高扇入

		- 工具类（被大量的类使用）

	- 低扇出

		- 少量或适中的使用其他类（7个以内）

	- 可移植性
	- 精简性

		- 一本书的完成，不在它不能再加入任何内容的时候，而在不能再删去任何内容的时候。

	- 层次性
	- 标准技术

- 设计的层次

	- 第一层：软件设计
	- 第二层：分解为子系统或包

		- 确定不同子系统之间相互通信的规则
		- 子系统交互关系

			- 子系统调用另一个子系统的子程序（简单）
			- 子系统包含另一个子系统中的类（复杂）
			- 子系统中的类继承自另一个子系统中的类（最复杂）

		- 常见子系统

			- 业务规则
			- 用户界面
			- 数据库访问
			- 对系统的依赖性

	- 第三层：分解为类
	- 第四层：分解成子程序
	- 第五层：子程序内部的设计

### 启发式设计

- 找出现实世界的对象
- 形成一致的抽象

	- 聚合物品
	- 基类

- 封装实现细节
- 当继承能简化设计时就继承

	- 辅佐抽象概念
	- 在运行期间才能确定所针对的对象的实际类型的操作--多态（polymorphism）

- 信息隐藏

	- 黑盒，隐藏复杂度
	- 接口尽可能少地暴露其内部工作机制

		- 减少改动所影响的代码量

	- 隐藏复杂度与变化源
	- 障碍

		- 信息过度分散

			- 系统内过度分散
			- 人机交互（UI、命令行）

				- 人机交互逻辑集中到单独的类、包或子系统

		- 循环依赖
		- 全局变量
		- 可以察觉的性能损耗

			- 避免过早优化

	- 价值

		- 促进好的设计决策

- 容易改变的区域

	- 措施

		- 找出看起来容易变化的项目
		- 把容易变化的项目分离出来
		- 把看起来容易变化的项目隔离开来

			- 把变化限制在类的内部

	- 区域

		- 业务规则
		- 对硬件的依赖
		- 输入和输出
		- 非标准的语言特性
		- 困难的设计区域和构建区域
		- 状态变量

			- 不要使用布尔量，使用枚举类型
			- 使用访问器子程序取代对状态变量的直接检查

		- 数据量的限制

	- 预料变化

		- 区分核心与附加功能

- 保持松散耦合

	- 耦合标准

		- 规模

			- 模块之间的连接数

		- 可见性

			- 模块之间连接的显著程度

				- 参数表（good）
				- 全局变量（bad）

		- 灵活性

			- 模块之间的连接是否容易改动

	- 耦合种类

		- 简单数据参数耦合

			- 通过参数传递数据且数据为简单类型

		- 简单对象耦合

			- 模块实例化一个对象

		- 对象参数耦合

			- obj1要求obj2传给它一个obj3

		- 语义上的耦合

			- 模块使用其他模块内部工作细节的语义知识

				- module1向module2传递一个控制标志
				- module2在module1修改全局变量后使用该全局变量
				- module暴露接口调用依赖
				- module1把obj传给module2
				- module1把baseObj传给module2，module2将其转化为派生对象

			- 危险

- 使用设计模式
- 其他

	- 高内聚

		- 类内部子程序及其内部代码紧密支持一个中心目标

	- 分层
	- 接口契约

		- 前条件、后条件

	- 对象分配职责
	- 为测试设计
	- 避免失误

		- 不只关注成功先例

	- 选择变量绑定时间

		- 考量代码复杂度和灵活性

	- 创建中央控制点

	  对于每一段有作用的代码，应该只有唯一的一个地方可以看到它，并且也只能在一个正确的位置去做可能的维护性修改

	- 暴力突破
	- 图

		- 图能在更高的抽象层次上表达问题

	- 模块化设计

		- 黑盒

### 设计实践

- 设计是一种迭代设计
- 分而治之
- 自上而下

	- 分解策略
	- 简单
	- 推迟构建细节

- 自下而上

	- 合成策略
	- 较早找出所需功能
	- 难以独立完成
	- 可能要先做高层设计

- 试验性原型
- 合作设计
- 记录设计成果

	- 设计文档插入代码

		- 注释中写明关键的设计决策

	- wiki
	- 总结邮件
	- 拍照
	- 设计挂图
	- CRC(类、指责、合作者)卡片
	- 在适当的细节层创建UML图

## 构建决策

### 编程语言

- Sapir-Whorf假说

  你思考的能力取决于你是否知道能够表达该思想的词汇

### 编程约定

- 变量名、类名、子程序名、格式约定、注释约定
- 各个具体部件都能反映整体架构的内涵

### 技术浪潮中的位置

- 深入一种语言去编程

	- 大多数重要的编程原则并不依赖特定的语言
	- 发明自己的编程约定、标准和类库

### 团队工作

- 集成工序
- 结对编程、独自编程

### 质量保证

- 单元测试
- check in流程

	- 调试器单步跟踪
	- 集成测试

- review

### 工具

- vcs
- 语言版本
- 编程框架
- 非标准语言特性
- 编辑器、重构工具、调试器、测试框架、语法检查器

## 可以工作的类

### 类

- 数据和子程序构成的集合
- 安全地忽略程序中尽可能多的其余部分
- 抽象数据类型加上继承和多态

### 类的基础：抽象数据类型（ADTs）

- 数据及对这些数据所进行操作的集合
- 益处

	- 隐藏实现细节
	- 改动不会影响到整个程序
	- 让接口能提供更多信息
	- 让程序的正确性更显而易见
	- 程序更具自说明性
	- 无需在内部到处传递数据
	- 不用在底层操作实体

- 示例

	- 底层数据类型创建为ADT而不再使用底层数据类型

		- 相对于队列、堆栈，尽可能使用最高层次的抽象

	- 文件系统
	- 简单事物
	- 类和访问器子程序的名字与存储结构的方式无关

- 非面向对象环境

	- 子程序

		- 指明示例

			- 如id索引

		- 明确提供实例

			- 不需索引但暴露了内部数据

		- 隐含实例(危险)

			- current

### 良好的类接口

- 冗余接口

	- 将一些子程序转移到其他更合适的类

- 接口展示一致的抽象层次

	- 把类看做一种用来实现抽象数据类型的机制

- 理解类所实现的抽象
- 提供成对的服务
- 把不相关的信息转移到其他类中

	- 一个类中的子程序使用一半数据而另一个子程序使用另一半数据

- 让接口可编程而不是表达语义

	- 可编程性：数据类型和其他属性
	- 语义通过注释说明

- 谨防在修改时破坏接口的抽象
- 不添加与接口抽象不一致的公用成员
- 同时考虑抽象性和内聚性，但抽象更重要

### 良好的封装

- 封装与抽象同在
- 限制类和成员的可访问性
- 不公开暴露成员数据
- 避免把私用的实现细节放入类的接口

	- 不能透过接口
	- 无法得知如何使用一个类时

		- 联系作者

			- 作者修改类的接口文档

- 低耦合

### 设计和实现

- 包含

	- has
	- 慎用private继承

		- 访问内层包含类的protected成员函数和数据成员

	- 警惕超过7个成员的类

		- 7±2原则

- 继承

	- 目的

		- 定义能为两个或更多派生类提供共有元素的基类的方式写出更精简的代码

	- 共有元素

		- 子程序接口、内部实现、数据成员、数据类型

	- 增加代码复杂度
	- 原则

		- 派生类需要完全遵守基类定义的同一个接口契约
		- public继承实现is关系
		- liskov替换原则

			- 派生类必须能通过基类的接口而被使用

		- 只继承需要继承的部分

			- 继承接口
			- 继承实现

				- 包含关系优先

		- 不要覆盖不可覆盖的成员函数

			- 如果要覆盖私有实现，使用接口

		- 共用数据和接口和操作放在继承树高层
		- 使用多态避免类型检查

			- 适当的时候使用case语句

		- 让所有数据都是private

			- 派生类如需访问数据则提供protected访问器函数

	- 误区

		- 只有一个实例的类
		- 只有一个派生类的基类
		- 继承体系过深

			- 层级不要超过3层
			- 派生类不要超过7±2

- 多重继承

	- 混合体（mixins）

		- 给对象增加一组属性的简单类

			- displayable
			- persistant
			- serializable
			- sortable

		- 混合体之间保持完全独立

- 规则

	- 多个类共享数据而非行为

		- 创建类可以包含的共用对象

	- 多个类共享行为而非数据

		- 从共同的基类继承，并在基类里定义公共的子程序

	- 多个类共享行为和数据

		- 从共同的基类继承，并在基类里定义公共的子程序和数据

	- 基类控制接口使用继承，自己控制接口使用包含

- 成员函数和数据成员

	- 子程序数量最少
	- 禁止隐式地产生不需要的成员函数和运算符

		- 如单例模式禁用构造函数

	- 减少调用子程序数量

		- 扇入

	- 减少其他类子程序调用

		- 比如调用成员对象的成员对象的子程序

- 构造函数

	- 尽量初始化所有数据成员
	- 私有构造函数实现单例
	- 优先使用深拷贝

### 创建类的原因

- 为现实世界中的对象建模
- 为抽象的对象建模
- 降低复杂度
- 隔离复杂度
- 隐藏实现细节
- 限制变动的影响范围
- 隐藏全局数据
- 让参数传递更流畅

	- 把大量的数据到处传递是在暗示换一种类的组织方式可能会更好

- 建立中心控制点

	- 文件、数据库连接、打印设备

- 让代码易于重用

	- 为重用而设计
	- 或者在项目结束时挑出被选代码并进行必要的工作让代码可重用

- 为程序族做计划

	- 替换项目中的一些业务类实现新的项目

- 相关操作包装到一起

	- 包、命名空间、头文件

- 实现某些特定的重构
- 避免的类

	- 万能类
	- 无关紧要的类

		- 只有数据没有行为

	- 动词命名的类

		- 只有行为没有数据

## 高质量的子程序

### 低质量的子程序

- 差劲的名字
- 没有文档
- 布局不好
- 修改输入
- 读写全局变量
- 没有单一目的
- 没有防范错误数据
- magic number
- 包含未使用的参数
- 错误的参数传递方式

	- 值、引用

- 参数太多

	- 7个左右

- 参数顺序混乱且未经注释

### 正当理由

- 降低复杂度

	- 子程序的抽象能力

- 引入中间、易懂的抽象
- 避免重复代码

	- 最普遍的原因

		- 提取相同代码放入基类，差异代码放入派生类
		- 相同的代码放入新的子程序、其余代码来调用这个子程序

- 支持子类化

	- 易于覆盖

- 隐藏顺序

	- 有顺序依赖的代码处于同一个子程序

- 隐藏指针操作
- 提高可移植性
- 简化复杂的布尔判断

	- 隔离判断细节
	- 通过描述性的函数名字概括判断的目的

- 改善性能

	- 隔离优化

- 确保所有的子程序都很小
- 过于简单的子程序

	- 自我注解

- 创建类的很多理由也是创建子程序的理由

### 子程序层上的设计

- 内聚性：子程序各种操作之间联系的紧密程度

	- 功能的内聚性

		- 最强也是最好的内聚性
		- 一个程序仅执行一项操作
		- 操作与名字相符

	- 顺序上的内聚性

		- 子程序内需要按特定顺序执行的操作，这些步骤需要共享数据，而且只有在全部执行完毕后才完成一项完整的功能

		  // 根据生日计算年龄和退休时间
		  // 计算退休时间需要先计算年龄
		  birthday -> age -> retire time
		  
		  // 拆解为两个子程序
		  // 1.根据生日计算年龄
		  birthday -> age
		  // 2.根据生日计算退休时间
		  // 调用根据生日计算年龄
		  birthday - (birthday -> age) -> retire time

	- 通信上的内聚性

		- 子程序中的不同操作使用了同样的数据，但不存在其他任何联系

			- 拆分并在高层调用

	- 临时的内聚性

		- 需要同时执行才放在一起执行的子程序
		- init,startup,shutdown
		- 让具有临时内聚性的子程序去调用其他的子程序

	- 不可取的内聚性

		- 过程上的内聚性

			- 子程序中的操作是按特定的顺序进行的，但操作之间并无关系

				- 拆分成功能内聚性的子程序

		- 逻辑上的内聚性

			- 若干操作被放入同一个子程序中，通过传入控制标志选择执行其中的一项操作，而不是因为各项操作之间有任何逻辑关联

				- if,else,switch包围

					- 移入低层子程序，若存在共用代码和数据，则将子程序包裹在类中

				- 事件处理器（可取的）

					- gui编程常见

		- 巧合的内聚性

### 子程序名字

- 描述子程序做的所有事情

	- 移除副作用

- 避免使用无意义的、模糊或表述不清的动词

	- 事件处理器中的handle例外
	- user,input,compute,calc,output,service

- 慎用数字
- 9-15字符
- 对返回值有所描述
- 语气强烈的动宾结构

	- 面向对象则使用动词即可

- 准确使用对仗词

	- add/remove

- 为常用操作建立命名规则

	- getElementById

### 子程序长度

- 100行以内，随着迭代增长到200行以内

### 子程序参数

- 39%的错误都是属于内部接口错误
- 按输入-修改-输出的顺序排列参数
- 标记in out(如有必要)
- 若多个子程序使用类似的参数则参数的排列顺序保持一致

	- fprintf()、printf()

- 使用所有的参数

	- 匿名函数除外

- 把状态或出错变量放在最后
- 不要把子程序参数用做工作变量
- 在接口中对参数的假定加以说明

	- 断言

- 参数个数限定在7个以内

	- 如果你向很多不同的子程序传递相同的数据，就将这些子程序组成一个类，并把那些经常使用的数据用作类的内部数据

- 考虑对参数输入、修改、输出使用某种命名规则
- 为子程序传递用以维持其接口抽象的变量和对象

	- 多参数传递和对象参数的选择取决于子程序的接口要表达何种抽象

		- 装配和拆卸都是子程序设计不佳的表现
		- 若频繁修改的参数都来自于同一个对象、

- 使用具名参数
- 实参与形参相匹配（c语言）

### 函数的使用

- 函数是指主要用途为取得返回值的子程序；过程是指没有返回值的子程序
- 函数返回

	- 检查所有可能的返回路径

		- 设置默认返回值

	- 不要返回指向局部数据的引用或指针

		- 支持闭包的语言除外

### 宏子程序和内联子程序

- 注意宏的展开
- 用宏代替函数调用的做法具有风险
- 限制宏的使用

	- const定义常量
	- inline定义内嵌代码
	- template安全安全的定义各种标准操作
	- enum定义枚举
	- typedef定义类型替换

- 内联子程序

	- 违反封装原则
	- 编译输出膨胀
	- 通过生成内嵌代码避免了子程序调用开销

## 防御式编程

### 防御式编程重点在于防御未曾预料到的错误

### 非法输入数据

- 检查所有来源于外部的数据的值

	- 文件
	- 用户
	- 网络
	- 外部接口
	- 长度、数值范围、注入、溢出、缓冲区

- 检查子程序所有输入参数的值
- 决定如何处理错误的输入数据

### 断言

- 一个描述为真时的布尔表达式
- 一个断言为假时需要显示的信息
- 检查

	- 输入输出参数取值范围
	- 开始结束时文件和流的开闭状态及读写位置
	- 文件流只读、只写、或可读写
	- 输入值没有被修改
	- 指针非空
	- 传入的数组和容器容量和状态
	- 表是否初始化

- 开发阶段使用，不编译进入产品代码
- 不支持断言的语言可通过宏实现
- 指导建议

	- 用错误处理代码来处理预期会发生的状况

		- 检查有害输入、外部系统的变量

	- 用断言来处理绝不应该发生的状况

		- 检查bug
		- 检查可信的内部系统变量
		- 可执行的注解

	- 避免把需要执行的代码放到断言中
	- 用断言来注解并验证前条件和后条件
	- 对于高健壮性的代码，先使用断言再处理错误

		- 回归测试不完整时
		- 历史原因，无法纠正所有错误时

### 错误处理技术

- 技术

	- 返回中立值

		- 0，空字符串，空指针

	- 换用下一个正确的数据
	- 返回与前次相同的数据
	- 使用最接近的合法值
	- 把警告信息记录到日志文件中
	- 返回一个错误码

		- 方法

			- 同状态值作为函数的返回值
			- 设置一个状态变量的值
			- 用语言内建的异常机制抛出一个异常

		- 若要保证安全性，需调用方子程序检查错误码

	- 调用错误处理子程序或对象

		- 集中处理
		- 紧密耦合
		- 不能处理缓冲区溢出错误

	- 显示出错消息

		- 本地化问题、易于攻击

	- 局部处理错误

		- 降低系统整体可靠性

	- 关闭程序

- 健壮性与正确性

	- 健壮性

		- 保证软件持续运转

	- 正确性

		- 永不返回不准确的结果

- 错误处理方式需要在高层设计时确认

### 异常

- 与继承一样，审慎明智地使用
- 用异常通知程序的其他部分，发生了不可忽略的错误
- 只有真正例外的情况下才抛出异常

	- 和断言类似
	- 弱化封装

- 不可用异常来推卸责任

	- 局部处理

- 避免在构造函数和析构函数中抛出异常、除非立即捕获
- 在恰当的层次抛出异常

	- 与子程序接口保持一致

- 在异常消息中加入关于导致异常发生的全部信息
- 避免使用空的catch语句

	- 低层次异常可文档化（log）

- 了解所用函数库可能抛出的异常
- 考虑创建一个集中的异常报告机制
- 把项目中对异常的使用标准化

	- 创建异常基类

		- 标准化记录日志、报告错误

- 考虑异常的替代方案

### 隔离程序

- 把某些接口选定为安全区域的边界

	- 在用户层和核心程序中建立验证层

- 类的层次

	- 公用方法假设数据不安全
	- 私用方法假定数据安全

- 手术室原则

	- 任何东西在允许进入手术室之前都要经过消毒处理

- 在输入数据时将其转换为恰当的类型

	- yes/no -> boolean

- 隔栏内部使用断言、外部使用错误处理技术

### 辅助调试的代码

- 应当在开发期间牺牲一些速度和对资源的使用，来换取一些可以让开发更顺畅的内置工具
- 尽早引入辅助调试代码
- 进攻式编程

	- 开发时让异常显现出来而在产品代码运行时让它自我恢复

		- case default
		- 断言终止程序
		- 完全填充所有内存
		- 确保所有分支能产生严重错误
		- 删除对象前填满垃圾数据
		- 让程序将错误日志发送邮件通知

- 计划移除调试辅助代码

	- 使用构建工具（ant,make,gradle）
	- 使用内置预处理器或宏

		- 可以定义调试代码级别

	- 编写自己的预处理器
	- 使用调试存根(debug stubs)

		- 调试阶段替代复杂子程序

### 确定在产品代码中该保留多少防御式代码

- 保留检查重要错误的代码
- 去掉检查检查细微错误的代码
- 去掉可以导致程序硬性崩溃的代码
- 保留可以让程序稳妥地崩溃的代码

	- 部分调试辅助代码

- 为技术支持人员记录错误信息

	- 断言->日志

- 确保产品及的错误消息是友好的

### 姿态

- 防御式编程增加了代码复杂度
- 因地制宜

## 伪代码

### 减少设计和编写文档所需的工作量

### 创建类的步骤

- 创建类的总体设计

	- 职责
	- 隐藏
	- 抽象概念
	- 继承
	- 公用方法
	- 重要数据成员

- 创建类的子程序
- 复审并测试整个类

### 创建子程序的步骤

- 设计子程序
- 检查设计
- 编写子程序代码
- 检查代码

### 伪代码编写

- 用类似英语的语句来精确描述特定操作
- 避免使用目标编程语言中的语法元素
- 在本意（intent）的层面上编写伪代码

	- 不在目标语言中实现

- 在足够低的层次上编写伪代码

### 通过伪代码生成代码，同时伪代码变成注释

### 好处

- 评审更容易，无需检察院代码就可以评审细节设计
- 支持反复迭代精化的思想

	- 从高层到底层

- 变更更加容易

	- 代价最小的阶段捕获到错误

- 减少注释工作量
- 比其他形式的设计文档更容易维护

	- 保持设计和代码一致

### 编码过程

- 设计子程序

	- 检查先决条件

		- 子程序定义
		- 契合需求

	- 定义子程序要解决的问题

		- 隐藏的信息

			- 如各种分支条件

		- 输入
		- 输出
		- 前条件

			- 如打开文件

		- 后条件

			- 如关闭文件

	- 命名
	- 决定如何测试

		- 可以提前准备测试用例

	- 在标准库中搜寻可用的功能
	- 考虑错误处理
	- 考虑效率问题

		- 一般抽象的优先级高于效率

			- 良好抽象的子程序便于优化效率

		- 性能攸关的子程序

			- 优先在高层优化

	- 研究算法和数据类型
	- 编写伪代码

		- 头部注释
		- 高层伪代码

	- 考虑数据

		- 定义好关键数据类型

	- 检查伪代码

		- 从伪代码层次能理解子程序

	- 在伪代码中试验一些想法，留下最好的想法（迭代）

- 编写子程序

	- 从伪代码开始

		- 写出子程序的声明

			- 接口声明
			- 伪代码 -> 头部注释

		- 编写第一条和最后一条语句，然后将伪代码转换为高层次的注释
		- 每条注释下面填充代码吗

			- 至少展开为2-10行

		- 持续分解

			- 展开过长

				- 重构新的子程序

			- 递归地应用伪代码编码过程

		- 检查代码

			- 脑海检查

				- 桌面检查
				- 同行评审
				- 只有5%错误是由硬件、编译器、操作系统引起

			- 编译子程序

				- 不要犯“只要再编译一次”的毛病
				- 脱离先东拼西凑、然后通过运行来查看代码是否工作的怪圈
				- 方法

					- 编译器警告级别调最高
					- 使用验证工具

						- lint
						- 尤其是不可编译语言

					- 消除所有产生错误消息和警告的所有根源

			- 在调试器中逐行检查代码
			- 测试代码

				- 测试用例
				- 测试脚手架

					- 测试夹子程序
					- 存根（stub）

			- 消除程序中的错误

		- 收尾工作

			- 检查子程序接口
			- 检查整体的设计质量
			- 检查子程序中的变量
			- 检查子程序的语句和逻辑
			- 检查子程序的布局
			- 检查子程序的文档
			- 除去冗余的注释

		- 根据需要重复上述步骤

			- 高质量的编程是一个迭代的过程

### 替代方案

- 测试先行开发
- 重构
- 契约式设计

	- 每一段程序都有前条件和后条件

- 东拼西凑

	- hacking

